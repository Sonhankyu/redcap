<?php

namespace Vanderbilt\REDCap\Classes\Fhir\DataMart;

use Vanderbilt\REDCap\Classes\Fhir\TokenManager\FhirTokenManager;
use Vanderbilt\REDCap\Classes\Queue\Queue;

class DataMartBackgroundRunner
{

    /**
     * DataMart instance
     *
     * @var DataMart
     */
    private $datamart;

    /**
     * collect procesing errors
     *
     * @var \Exception[]
     */
    private $errors = [];

    /**
     * total MRN processed
     *
     * @var integer
     */
    private $mrnCounter = 0;

    /**
     *
     * @param DataMart $datamart
     */
    function __construct($datamart)
    {
        $this->datamart = $datamart;
    }
    /**
     *
     * @param int $userId
     * @param DataMartRevision $revision
     * @param Message $message
     * @return void
     */
    private function sendBackgroundProcessCompleted($userId, $designatedUserId, $revision, $hasMore, $message)
    {
        $project_id = $revision->project_id;
        $projectInfo = $this->datamart->getProjectInfo($project_id);
        $project_title = $projectInfo->app_title;
        $project_creator = $projectInfo->created_by;
        
        if($userId == $designatedUserId) $toID = $userId;
        else $toID = $project_creator;
        $userInfo = \User::getUserInfoByUiid($toID);
        $to = @$userInfo['username'];

        $totalProcessedMrns = $this->getMrnCounter();
        
        $title = 'Data Mart Revision was run';
        $msg = '[This message was automatically generated by REDCap]'.PHP_EOL;
        $msg .= sprintf('The Data Mart revision ID `%u` has been processed in the project `%s` (ID %u).', $revision->id, $project_title, $project_id);
        if($this->hasErrors()) {
            $msg .= PHP_EOL."The following errors were logged:";
            foreach ($this->getErrors() as $error) {
                $msg .= sprintf("\t- %s".PHP_EOL, $error->getMessage());
            }
        }
        $pluralForm = ($totalProcessedMrns===1) ? '' : 's';
        $msg .= sprintf(PHP_EOL.'Data has been fetched for %u MRN%s.', $totalProcessedMrns, $pluralForm);
        if($hasMore) {
            $msg .= "Please note:\nthe process has been splitted for performance reasons; you will get another message as soon as the next chunk is completed.";
        }
        $from = $project_creator;
        \Messenger::createNewConversation($title, $msg, $from, $users=$to, $project_id);
    }

    /**
     * get any user in the project with a valid id if the one provided is not valid 
     *
     * @param int $project_id
     * @return int|false valid user ID or false if none is found
     */
    private function getDesignatedUserId($project_id) {
        $designatedUserId = $this->datamart->getUserId();
        if(intval($designatedUserId)==0) {
            $users = FhirTokenManager::getUsersWithValidTokenInProject($project_id);
            $designatedUserId = reset($users);
        }
        if(!$designatedUserId) return false;
        return $designatedUserId;
    }

    /**
     * get a DateTime to use as reference
     * for execution time
     *
     * @param string $time_string
     * @return DateTime
     */
    private function getMaxExecutionTime($time_string='30 minutes') {
        $start = new \DateTime();
        $max_execution = \DateInterval::createFromDateString($time_string);
        $max_time = $start->add($max_execution);
        return $max_time;
    }

    public function incrementCounter()
    {
        $this->mrnCounter++;
    }

    public function getMrnCounter()
    {
        return $this->mrnCounter;
    }

    /**
     *
     * @param array $errors
     * @return void
     */
    public function addError($error) {
        $this->errors[] = $error;
    }

    public function getErrors()
    {
        return $this->errors;
    }

    /**
     *
     * @return boolean
     */
    private function hasErrors()
    {
        return count($this->errors)>0;
    }

    /**
     * schedule a process that will run a DataMart revision in background
     *
     * @param int $revisionId
     * @param array $mrn_list
     * @param boolean $sendFeedback
     * @return void
     * @throws \Exception
     */
    public function schedule($revisionId, $mrn_list=[], $sendFeedback=false)
    {
        $inferNext = !(is_array($mrn_list) && count($mrn_list)>0);
        $revision = DataMartRevision::get($revisionId);
        if($revision==false) throw new \Exception(sprintf('No revision found with the ID \'%u\'.', $revisionId), 404);
        $project_id = $revision->project_id;

        // get any user in the project with a valid id if the one provided is not valid 
        $userId = $this->datamart->getUserId();

        // create a key to identify the message in the queue (different name for each project/revision)
        $messageKey = sprintf('DataMart-%u (%u)', $project_id, $revisionId);
        
        /**
         * create a callback that will be run by the worker in the queue
         * 
		 * @param DataMartRevision $revision
		 * @param int $designatedUserId user that will be used to fetch data. could be different from the datamart user
		 * @param array $mrn_list optional list of MRNs to fetch
		 */
		$addMessage = function($revisionId, $designatedUserId, $mrn_list) use($userId, $project_id, $messageKey, $inferNext, $sendFeedback, &$addMessage){
			/**
			 * @param Message $message
			 */
			$callable = function($message) use($revisionId, $designatedUserId, $userId, $mrn_list, $inferNext, $sendFeedback, &$addMessage) {
				global $project_id;
                $revision = DataMartRevision::get($revisionId);
				$project_id = $revision->project_id; //set the scope of the project (for logging etc...)
				// set a designated user.

				if(!is_array($mrn_list)) $mrn_list = [];

				$datamart = new DataMart($designatedUserId);
                $bgRunner = new DataMartBackgroundRunner($datamart);

				$maxTime = $bgRunner->getMaxExecutionTime('30 minutes');
				do {
                    $mrn = array_shift($mrn_list);
					$result = $datamart->runRevision($revision->id, $mrn);
                    if($inferNext) {
					    $nextMrn = @$result['metadata']['next_mrn']; // get the next MRN
                        if($nextMrn) $mrn_list[] = $nextMrn;
                    }
                    // collect errors
                    $hasErrors = @$result['has_errors'];
                    if($hasErrors) {
                        $errors = @$result['errors'] ?? [];
                        foreach ($errors as $error) $bgRunner->addError($error);
                    }

					$now = new \DateTime();
					$tooMuch = $now>$maxTime;
                    $hasMore = count($mrn_list)>0;
                    if($mrn) $bgRunner->incrementCounter();
					if($tooMuch && $hasMore) {
						/**
						 * create a new message if the process is taking
						 * too much time and there are more MRNs to process
						 */
						$addMessage($revision->id, $designatedUserId, $mrn_list);
					}
				} while ($hasMore && !$tooMuch);
                if($sendFeedback) {
                    $bgRunner->sendBackgroundProcessCompleted($userId, $designatedUserId, $revision, $hasMore, $message);
                }
			};
            
			// $callable();
            Queue::addMessage($messageKey, $callable);
		};

        $designatedUserId = $this->getDesignatedUserId($project_id);
        if(!$designatedUserId) {
            $message = sprintf('Unable to schedule the revision ID `%u`', $revisionId);
            $message .= PHP_EOL;
            $message .= sprintf('No valid access tokens found for any user in the project `%u`.', $project_id);
            throw new  \Exception($message, 400);
        }
        $existingMessages = Queue::getMessagesByKey($messageKey, [Queue::STATUS_PROCESSING, Queue::STATUS_READY]);
        if(!empty($existingMessages)) throw new \Exception("No background fetch was scheduled because there is a previous process waiting to be processed.", 401);

        $addMessage($revisionId, $designatedUserId, $mrn_list);
            
    }
    
}

